<?xml version="1.0" encoding="utf-8"?>
<Namespace DisplayName="::vl::regex_internal">
  <Overloads DisplayName="AlternateExpression class">
    <Symbol Key="::vl::regex_internal::AlternateExpression" UrlName="vl.regex_internal.AlternateExpression" Doc="false" />
  </Overloads>
  <Overloads DisplayName="AreEqual function">
    <Symbol Key="::vl::regex_internal::AreEqual(* Transition,* Transition)" UrlName="vl.regex_internal.AreEqual(^ Transition,^ Transition)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="Automaton class">
    <Symbol Key="::vl::regex_internal::Automaton" UrlName="vl.regex_internal.Automaton" Doc="false" />
  </Overloads>
  <Overloads DisplayName="BeginExpression class">
    <Symbol Key="::vl::regex_internal::BeginExpression" UrlName="vl.regex_internal.BeginExpression" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CaptureExpression class">
    <Symbol Key="::vl::regex_internal::CaptureExpression" UrlName="vl.regex_internal.CaptureExpression" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CaptureRecord class">
    <Symbol Key="::vl::regex_internal::CaptureRecord" UrlName="vl.regex_internal.CaptureRecord" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CharRange class">
    <Symbol Key="::vl::regex_internal::CharRange" UrlName="vl.regex_internal.CharRange" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CharSetExpression class">
    <Symbol Key="::vl::regex_internal::CharSetExpression" UrlName="vl.regex_internal.CharSetExpression" Doc="false" />
  </Overloads>
  <Overloads DisplayName="EndExpression class">
    <Symbol Key="::vl::regex_internal::EndExpression" UrlName="vl.regex_internal.EndExpression" Doc="false" />
  </Overloads>
  <Overloads DisplayName="EpsilonNfaToNfa function">
    <Symbol Key="::vl::regex_internal::EpsilonNfaToNfa(Automaton::Ref,* function (* Transition) : bool,&amp; collections::Dictionary&lt;* State, * State&gt;)" UrlName="vl.regex_internal.EpsilonNfaToNfa(Automaton.Ref,^ function (^ Transition) # bool,&amp; collections.Dictionary{^ State, ^ State})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="EscapeTextForRegex function">
    <Symbol Key="::vl::regex_internal::EscapeTextForRegex(&amp; const WString)" UrlName="vl.regex_internal.EscapeTextForRegex(&amp; const WString)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="Expression class">
    <Symbol Key="::vl::regex_internal::Expression" UrlName="vl.regex_internal.Expression" Doc="false" />
  </Overloads>
  <Overloads DisplayName="IRegexExpressionAlgorithm class">
    <Symbol Key="::vl::regex_internal::IRegexExpressionAlgorithm" UrlName="vl.regex_internal.IRegexExpressionAlgorithm" Doc="false" />
  </Overloads>
  <Overloads DisplayName="IsRegexEscapedLiteralString function">
    <Symbol Key="::vl::regex_internal::IsRegexEscapedLiteralString(&amp; const WString)" UrlName="vl.regex_internal.IsRegexEscapedLiteralString(&amp; const WString)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="LoopExpression class">
    <Symbol Key="::vl::regex_internal::LoopExpression" UrlName="vl.regex_internal.LoopExpression" Doc="false" />
  </Overloads>
  <Overloads DisplayName="MatchExpression class">
    <Symbol Key="::vl::regex_internal::MatchExpression" UrlName="vl.regex_internal.MatchExpression" Doc="false" />
  </Overloads>
  <Overloads DisplayName="NegativeExpression class">
    <Symbol Key="::vl::regex_internal::NegativeExpression" UrlName="vl.regex_internal.NegativeExpression" Doc="false" />
  </Overloads>
  <Overloads DisplayName="NfaToDfa function">
    <Symbol Key="::vl::regex_internal::NfaToDfa(Automaton::Ref,&amp; collections::Group&lt;* State, * State&gt;)" UrlName="vl.regex_internal.NfaToDfa(Automaton.Ref,&amp; collections.Group{^ State, ^ State})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="NormalizeEscapedTextForRegex function">
    <Symbol Key="::vl::regex_internal::NormalizeEscapedTextForRegex(&amp; const WString)" UrlName="vl.regex_internal.NormalizeEscapedTextForRegex(&amp; const WString)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ParseAlt function">
    <Symbol Key="::vl::regex_internal::ParseAlt(&amp; * const wchar_t)" UrlName="vl.regex_internal.ParseAlt(&amp; ^ const wchar_t)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ParseCharSet function">
    <Symbol Key="::vl::regex_internal::ParseCharSet(&amp; * const wchar_t)" UrlName="vl.regex_internal.ParseCharSet(&amp; ^ const wchar_t)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ParseExpression function">
    <Symbol Key="::vl::regex_internal::ParseExpression(&amp; * const wchar_t)" UrlName="vl.regex_internal.ParseExpression(&amp; ^ const wchar_t)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ParseFunction function">
    <Symbol Key="::vl::regex_internal::ParseFunction(&amp; * const wchar_t)" UrlName="vl.regex_internal.ParseFunction(&amp; ^ const wchar_t)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ParseJoin function">
    <Symbol Key="::vl::regex_internal::ParseJoin(&amp; * const wchar_t)" UrlName="vl.regex_internal.ParseJoin(&amp; ^ const wchar_t)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ParseLoop function">
    <Symbol Key="::vl::regex_internal::ParseLoop(&amp; * const wchar_t)" UrlName="vl.regex_internal.ParseLoop(&amp; ^ const wchar_t)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ParseRegexExpression function">
    <Symbol Key="::vl::regex_internal::ParseRegexExpression(&amp; const WString)" UrlName="vl.regex_internal.ParseRegexExpression(&amp; const WString)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ParseUnit function">
    <Symbol Key="::vl::regex_internal::ParseUnit(&amp; * const wchar_t)" UrlName="vl.regex_internal.ParseUnit(&amp; ^ const wchar_t)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="PositiveExpression class">
    <Symbol Key="::vl::regex_internal::PositiveExpression" UrlName="vl.regex_internal.PositiveExpression" Doc="false" />
  </Overloads>
  <Overloads DisplayName="PureEpsilonChecker function">
    <Symbol Key="::vl::regex_internal::PureEpsilonChecker(* Transition)" UrlName="vl.regex_internal.PureEpsilonChecker(^ Transition)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="PureInterpretor class">
    <Symbol Key="::vl::regex_internal::PureInterpretor" UrlName="vl.regex_internal.PureInterpretor" Doc="false" />
  </Overloads>
  <Overloads DisplayName="PureResult class">
    <Symbol Key="::vl::regex_internal::PureResult" UrlName="vl.regex_internal.PureResult" Doc="false" />
  </Overloads>
  <Overloads DisplayName="RegexExpression class">
    <Symbol Key="::vl::regex_internal::RegexExpression" UrlName="vl.regex_internal.RegexExpression" Doc="false" />
  </Overloads>
  <Overloads DisplayName="RegexExpressionAlgorithm class">
    <Symbol Key="::vl::regex_internal::RegexExpressionAlgorithm`2" UrlName="vl.regex_internal.RegexExpressionAlgorithm`2" Doc="false" />
    <Symbol Key="::vl::regex_internal::RegexExpressionAlgorithm`1&lt;void,ParameterType&gt;" UrlName="vl.regex_internal.RegexExpressionAlgorithm`1{void,ParameterType}" Doc="false" />
  </Overloads>
  <Overloads DisplayName="RichEpsilonChecker function">
    <Symbol Key="::vl::regex_internal::RichEpsilonChecker(* Transition)" UrlName="vl.regex_internal.RichEpsilonChecker(^ Transition)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="RichInterpretor class">
    <Symbol Key="::vl::regex_internal::RichInterpretor" UrlName="vl.regex_internal.RichInterpretor" Doc="false" />
  </Overloads>
  <Overloads DisplayName="RichResult class">
    <Symbol Key="::vl::regex_internal::RichResult" UrlName="vl.regex_internal.RichResult" Doc="false" />
  </Overloads>
  <Overloads DisplayName="SequenceExpression class">
    <Symbol Key="::vl::regex_internal::SequenceExpression" UrlName="vl.regex_internal.SequenceExpression" Doc="false" />
  </Overloads>
  <Overloads DisplayName="State class">
    <Symbol Key="::vl::regex_internal::State" UrlName="vl.regex_internal.State" Doc="false" />
  </Overloads>
  <Overloads DisplayName="Transition class">
    <Symbol Key="::vl::regex_internal::Transition" UrlName="vl.regex_internal.Transition" Doc="false" />
  </Overloads>
  <Overloads DisplayName="UnescapeTextForRegex function">
    <Symbol Key="::vl::regex_internal::UnescapeTextForRegex(&amp; const WString)" UrlName="vl.regex_internal.UnescapeTextForRegex(&amp; const WString)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="UsingExpression class">
    <Symbol Key="::vl::regex_internal::UsingExpression" UrlName="vl.regex_internal.UsingExpression" Doc="false" />
  </Overloads>
</Namespace>